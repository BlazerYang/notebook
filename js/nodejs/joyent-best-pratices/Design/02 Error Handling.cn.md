# NodeJS产品最佳实践之错误处理
>译者注：  
This article is translated from "[https://www.joyent.com/node-js/production/design/errors](https://www.joyent.com/node-js/production/design/errors)" by [Joyent](www.joyent.com)(All rights reserved)  
原文链接"[https://www.joyent.com/node-js/production/design/errors](https://www.joyent.com/node-js/production/design/errors)", 作者[Joyent](www.joyent.com)(版权所有)

长久以来，在Node.js中，错误处理是一个痛点，即使你没有正确地处理错误，也可以轻易地绕过它。但是，想要开发健壮的应用就必须正确地处理错误，而且它学起来也不难。如果你真的没有耐心的话，可以直接拉到到总结处，中间的直接跳过即可。

本文会回答若干Node.js初学者常问的几个问题：

* 我写的函数里，应该什么时候抛出错误，应该什么时候通过回调、事件发射器或者其他什么东西发射出去？
* 我应该如何假设函数的输入？是否应该检查他们的类型是否正确？是否应该检查地更加详细，比如参数是否非null，是否非负，是否为合法ip地址？
* 我应该如何处理那些非法的函数输入？直接抛出异常还是通过回调传递错误？
* 我如何在代码中区分不同种类的错误（比如，一个“错误请求”错误 和一个“服务不可用”错误）？
* 我应该如何提供足够的细节以便调用者知道如何处理错误？
* 我应该如何处理意外的错误？用try/catch、作用域还是其他什么？

本文分为以下几个相辅相成的几个部分：

* **背景**：你需要具备的一些知识。
* **运行错误和编码错误**：介绍两种基本的不同种类错误
* **函数编写的模式**： 能够产生有用错误信息的一般函数编写规则
* **编写新函数的详细建议**：一个如何编写出能够产生有用错误信息的健壮函数的详细指导原则检查表
* **举个~~栗子~~例子**：例子文档和连接函数的前言
* **总结**： 相关知识点总结
* **附录**：Error对象通用属性：可标准化提供额外信息的属性名列表

## 背景
本文已假设：
* 你已经熟悉JS、Java、Python、C++或其他相似语言中异常的概念，而且你知道如何抛出并捕获他们。
* 你已经熟悉Node.js下的编程，适应异步操作和通过callback(err, result)来完成异步操作
* 你知道为什么下面这个模式捕获不到错误

```javascript
function myApiFunc(callback) {
  /*
   * This pattern does NOT work!
   */
  try {
    doSomeAsynchronousOperation((err) => {
      if (err) {
        throw (err);
      }
      /* continue as normal */
    });
  } catch (ex) {
    callback(ex);
  }
}
```

你应该同样熟悉下面这四种在Node.js中传递错误的方式：

* 直接throw一个错误（会使其变为异常）
* 将错误传递给回调函数，该函数提供传递错误信息和异步操作结果的功能
* 通过的Promise的reject函数来传递
* 通过事件发射器来发射error事件

下面我们会讨论如何使用这些方式。本文并不会假定你已经了解作用域的概念。

最后，你应该知道在JS中（特别是Node.js），错误和异常的差别。错误是Error类的一个对象。错误可以被构造然后传递到其他函数中或是直接抛出。当你抛出了一个错误时，它才会变成一个异常。

下面是将错误当做异常来用的一个例子：

```javascript
throw new Error('something bad happened');
```
你也可以正常创建一个错误而不抛出：

```javascript
callback(new Error('something bad happened'));
```
这种方式在Node.js中更加常见，因为大多数错误都是异步的。我们会看到，在同步函数中捕获一个错误是比较少见的。这个是和其他重度依赖使用异常的语言的显著不同，比如Java，C++等。

## 运行错误与编码错误
将所有错误分为两个广义的类是非常有帮助的：

* **运行错误**代表一个正确编写的程序中在运行时出现的错误。这些错误并不是程序的bug。事实上，这些通常是其他方面的问题：比如系统本身（e.g.，内存耗尽或打开文件太多），或系统配置（e.g.，远程主机无法连通），或网络问题（e.g.,socket挂起），或者远程服务（e.g.，500错误，连接失败等）。比如：
  * 连接服务器失败
  * 无法解析域名
  * 无效用户输入
  * 请求超时
  * 服务器返回500错误
  * socket挂起
  * 系统内存耗尽
* **编码错误**就是程序中的bug。这些错误都可以通过改写代码来解决。他们永远也不会被妥善处理（因为根据定义来说，这样的代码已经崩溃了）
  * 尝试读取undefined的属性
  * 调用异步函数却没有传递回调函数
  * 期望输入object，实际输入string
  * 期望为IP地址的字符串，却传了一个对象

人们使用术语“错误”来描述运行错误和编码错误，但是实际上他们的区别相当大。运行错误是所有正确的程序都需要处理的错误环境，而且在处理它们的时候，并不意味着发生了什么bug或者严重问题。“文件不存在”是一个运行错误，但并不意味着什么东西错了。只是意味着程序必须创建一个新的文件。

相对而言，编码错误就是bug。它们就是你犯下的错，像是忘记校验用户输入，打错了变量名等等。从定义来讲，并没有方法来处理他们。如果有的话，你就可以在发现错误的地方使用错误处理函数了。

这个区别很重要：运行错误是正常程序运行中的一部分，而编码错误就是bug。

有时，在同一个问题中可能会同时包含着两种错误。如果一个HTTP服务器尝试使用一个undefined变量然后崩溃了，那这就是一个编码错误。任何在此时正在请求的客户端都会收到一个ECONNRESET错误，在Node中一般是以“socket hang-up”错误抛出。对客户端来说，这只是另外一个运行错误而已。因为正确的客户端必须正确处理服务器崩溃或者网络不可用。

相似地，没有正确处理运行错误本身就是编码错误。比如，一个程序尝试去连接一个服务器，然后产生了ECONNREFUSED错误，但没有在socket上注册error事件的回调函数，那么程序就会崩溃，因为这就是一个编码错误。连接失败是运行错误（因为这是任何正常程序都会遇到的问题，在网络断开或者系统中其他组件不可用的时候），但是没有正确处理的话，即为一个编码错误。

理解运行错误和编码错误的区别是理清如何传递并处理错误的基础。请确保你在阅读下文前已充分理解这个概念。

## 处理运行错误
就像性能和安全一样，错误处理并不是什么能直接扣到一个没有任何错误处理的程序上的组件。你既不能在程序中集中处理错误，就像你不能将性能问题集中处理一样。代码在进行任何可能导致错误的操作时（比如打开文件，连接服务器，开启子进程等等）都必须考虑到可能的失效。其中包含了你了解失效原因（失效模式），以及可能出现的失效状况。这个稍后详述，现在的关键点是错误处理必须足够细致，因为其影响完全取决于失效主体以及失效原因？

你可能在调用栈之中处理了相同的错误好几次。这在底层函数不知道如何处理错误只得向上传递时经常发生。通常，只有顶层调用者知道如何做出恰当的响应：是重试，还是向用户报告错误，或者其他操作。但这并不意味至你应该把所有的错误都抛给同一个顶层回调，因为调用者本身不知道错误发生的上下文，一个操作中的哪些部分成功了，哪些部分失败了。

具体地说。对于任何错误，你都需要考虑以下几点：

* **直接处理失败**。有时候，错误处理方法显而易见。如果你在读取日志文件时发生了ENOENT错误，可能是因为程序第一次启动，你需要在读取日志前先创建它。另一个更有意思的例子是，在维护一个服务器的socket连接（比如数据库）时出现了一个"socket hang up"错误。这通常是因为另一端意外断开或者网络中断，经常持续很短时间，那么常见的解决方式就是重新连接。（这跟下面要将讲到的重试不一样，因为你在看到这个错误时并不一定在执行什么操作）。
* **将错误报告给客户端**。如果你不知道如何处理错误，那么最简单的方式就是立即中断操作，清理工作区，并将错误报告给你的客户端。（如何传递错误是另外一个问题，下面会谈到）这在错误原因是固定的情况下比较合适：比如用户发送给你一段无效的JSON数据，那么重新解析是没有任何帮助的。
* **重试操作**。对于网络或者远程服务的错误来说，有时在出错时重试是个很好的解决方案。比如，如果远程服务返回503（服务不可用错误），而你想要在若干秒之后重试。**如果你想用重试的话，那你应该清晰说明你将要重试几次，重试几次后失败，以及每次重试间隔的时长**。另外，**不要认为你总是应该进行重试操作**。如果你在一个调用栈的层级较深（比如你是被一个客户端A调用，而客户端A是被另一个客户端B调用，客户端B又被一个人来调用），那么通常快速失效并让客户端决定是否重试会更好。如果调用栈的每一层都去进行错误重试，那么用户的等待时间将会大大延长，因为每一层都不知道下一层同样在进行重试操作。
* **原地爆炸**。对于确定不该发生的错误，或者曾经发生过确实是编码错误的错误（比如无法连接本地socket，因为本程序已经占用了该端口），那么最好的办法就是记录错误信息然后崩溃掉。其他比如内存耗尽这种像JavaScript这样的动态语言无法处理的错误，比较合理的办法就是直接崩溃。（也就是说，你会在某个具体操作比如child_process中收到ENOMEM错误，如果你可以合理处理的话，那么你应该考虑处理掉这个错误）。如果发生了你无法合理处理或者需要管理员来修复的问题，那么也可以直接崩溃。比如，如果你遇到文件描述符耗尽或者无访问配置文件权限，那你已经无能为力了，必须让用户登录并修复这个问题。
* **记录错误 - 然后什么都不做**。有时候，有的错误你是无能为力的，既没有东西去重试或终止，也没有什么理由让程序崩溃。举个栗子，你正在使用DNS记录一组远程服务，然后其中一个服务的DNS失效了，那么你除了记录错误日志然后继续处理剩余的服务之外没有其他办法了。在这个例子里，你至少应该记些东西下来。（凡事无绝对。如果一个错误每秒发生1000次，那每次都记录错误是不值当的，隔段时间记一次即可）。

## （不要）处理编码错误
对编码错误而言，你无需进行错误处理。由定义可知，实现某种功能的代码出错（类似拼错变量名这种），你无法通过写更多的错误处理代码来修复它。如果你能做到，那就直接使用错误处理来做就行了。

有的人提倡在编码错误发生后恢复，也就是说，允许当前操作失败，但是保持处理请求。但是不推荐这么做。譬如一个编码错误是你在写代码时没有考虑到的情况，那么你如何保证这个错误不会影响到其他请求。如果其他请求共享某个通用状态（服务器、socket连接、数据库连接池等），那么其他请求很可能也不能正常工作了。

一个典型的例子是REST服务器（比如使用restify），其中某个请求处理函数抛出了一个引用错误（比如敲错了变量名）。有许多方法可以让程序继续运行，但是这样会导致难以追踪且很严重的bug。比如下面的这些例子：

1. 一些请求之间共享的状态可能会被置为null、undefined或者其他无效内容，使得下一个尝试使用该状态的请求同样会报错。
2. 数据库（或其他）连接可能会泄露，导致并行请求容量下降。情况持续恶化会导致你的可用连接越来越少，最后你的程序处理能力会从并行变为串行。
3. 更糟一点，一个留下未关闭事物的postgres连接。这会导致postgres挂在表中老的数据上，因为这些数据可能是包含在该事物中的。这个事物可能保持打开状态数周之久，导致表的有效体积无止境地增大，使得后续请求耗时成数量级增加，从几毫秒直至几分钟。尽管这个问题只会出现在postgres中，但这个例子清晰地反应出一个简单的编码错误可能会导致严重的错误。
4. 一个连接可能没有清除授权状态，然后就用在了后续连接之中。你可能会为错误的用户运行了请求。
5. socket连接可能没有关闭。Node通常会关闭空闲超过2分钟的套接字，但是这个时间有可能被覆盖，这可能会导致文件描述符泄露。如果泄露足够多的话，文件描述符可能会耗尽进而导致崩溃。即便你没有覆盖超时时间，客户端也有可能挂起2分钟然后报出一个意外的"hangup"错误。这2分钟的延迟使得问题处理和调试起来非常麻烦。
6. 内存引用残留。这会导致内存泄露，进而导致内存耗尽，或者（更糟的话）增加GC耗时，导致巨大的性能问题。这个问题很难调试，而且要将其同编码错误联系起来也是相当复杂。

**从编码错误中恢复的最好方式就是直接崩溃**。你应该使用自动重启工具启动你的程序，这样在其崩溃后可以重新运行。有重启工具的话，崩溃就是在面对编码错误时最快恢复服务的方法。

唯一的缺点是因为编码错误导致的崩溃会使得所有已连接的客户端暂时中断，但是记住：

* 由定义可知，这是错误都是bug。我们不是说系统权限或网络错误，而是程序中真实存在的bug。它们不应该在产品中出现，应该是最优先被处理掉的。
* 对于上述例子而言（还有其他更多的），正在发送的请求并不是必须成功完成的。他们有可能成功完成，有可能使得服务器再次崩溃，有可能以明显出错的方式结束，也有可能以难以调试的原因结束。
* 在一个可靠的分布式系统中， 客户端必须可以通过重新连接和重试请求的方式处理服务器错误。网络和系统错误是客观存在的，不论Node.js程序本身是否允许崩溃。
* 如果你的产品崩溃地太频繁以至于正常提供服务都成了难题，那么真正的问题是服务器的bug太多，而不是因为某个单一的bug。

如果因为服务器挂机太频繁导致客户端经常断线，那么你应该关注一下导致服务崩溃的bug，然后将其变为异常，而不是尝试避免某些明显错误的代码崩溃。[最好的调试方法是配置Node在遇到未捕获的异常时打印内核信息](https://www.joyent.com/node-js/production/debug#postmortem)。在GNU/Linux和基于illumos的系统上，利用这些内核信息，你可以看到程序崩溃的调用栈信息，以及每层函数的参数和其他大多数的JavsScript对象，即使其是在闭包中引用的。即使没有配置打印内核信息，你仍可以使用调用栈信息和日志来着手调查一个问题。

最后，务必记住服务器的一个编码错误只不过是客户端的一个运行错误。客户端必须去处理服务器崩溃和网络波动。这可不是纸上谈兵，而是在生产环境上真实发生的事情。

## 函数编写模式
我们已经讨论过如何处理错误，但当你编写新函数时，你应该如何将错误传递给调用函数的代码呢？

最重要的一点就是**说明**函数功能，包括函数使用的变量（类型及其他限制）、返回值、可能发生的错误以及错误的含义。**如果你不知道会发生什么错误或者错误的含义，那么你的程序是不可能正常运行的**。所以如果你正在写一个新函数，你必须告诉你的调用者可能发生什么错误，以及他们的含义。

## 抛出、回调、拒绝还是发射？
函数传递错误有若干基本的模式：

* 抛出是同步传递错误的方式，即与函数被调用处是相同的环境。如果调用者（或者调用者的调用者...）使用try/catch，那么他们就可以捕获这个错误。如果没有任何一层调用者这么做，那么程序通常会崩溃。（该错误可以通过域或者进程范围内的"uncaughtException"事件处理，下面会讨论到）
* 回调是最基础的异步传递错误方式。用户传递给你一个函数（回调），然后你在异步操作完成之后调用该函数。通常的用法是通过callback(err, result)的方式调用，其中err和result有且仅有一个为非空，取决于操作是成功还是失败。
* 拒绝Promise是一个常用的异步传递方式。这种方式在Node.js 8.0支持async/await特性之后日益流行。Async/await允许异步代码使用类似同步代码的方式来编写，并用try/catch捕获错误。
* 对于更复杂的情况不再使用回调，而是函数本身会返回一个EventEmitter对象。调用者可以监控对象的error事件。该模式在两个特定情况中有用：
  * 当你在进行一个可以产生多个错误或多个结果的复杂操作时。比如说，请求从一个数据库获取记录，并在收到数据时将其发送回请求方，而不是先等待获取所有数据。此例中，不再用回调函数，而是返回一个事件发射器，然后在每一个结果发送一个row事件，当所有结果读取完毕时，发送一个end事件，如果有错误发生时，发射error事件。
  * 对于表示复杂状态的对象来说，许多不同的异步事件都有可能发生。比如，socket连接就是一个可能发射"connect","end","timeout","drain","close"事件的事件发射器。那么让套接字再多一个可抛出事件"error"就显得水到渠成。当你采用这个方案时，必须得清楚发射“error”事件的时机，是否会有其他事件同时发射，此时可能会有其他什么事件（比如close），事件的顺序，套接字是否会在close事件后关闭。

"异步错误传递"的大部分章节都会用来说明回调和事件发射模式。如果你想要异步传递错误的话，一般都是用这两个中的一个，但不会全部都用。

所以，何时用throw，何时用回调或事件发射？主要看两点：

* 这个错误是运行错误还是编码错误？
* 这个函数本身是异步还是同步的？

目前为止，异步函数中最常见的状况是运行错误。其中大多数，将回调作为函数的参数，然后将错误传递给回调函数。这个模式好用且被广泛采纳。比如Node中的fs模块。如果你想要看看比上面描述中更复杂的例子，你可以尝试使用事件发射模式，但是其还是异步传递错误。

下一个最常见的例子是同步函数中的运行错误，比如JSON.parse。对于这个函数，如果你遇到运行错误（比如无效的用户输入），你必须同步传递错误。你可以选择抛出（常用）或者返回它。

对于一个给定的函数，如果任何运行错误都可以异步传递，那么就异步传递。也许你当时就知道了请求会失败，但不是由于编码错误。也许是因为函数缓存了最近请求的结果，但是该缓存中有一个稍后会发送给调用者的错误记录。即使你已经知道这次结果会失败，你也应该异步传递错误。

通用准则是**一个函数可以同步传递（比如抛出异常）或者异步传递（通过回调或事件发射器）运行错误，但不能同时采用两种模式。**也就是说，用户可以选择使用try/catch或者回调来处理错误，但不能两者都用。他们选取哪个取决于函数是如何传递错误的。其应该在函数文档中予以说明。

我们还没有说明编码错误。还记得它们是bug吧。它们通常可以通过在函数头部检查变量的类型（或者其他限制）发现。举个比较low的例子：调用异步函数而不写回调函数。那你应该立即抛出错误，这是调试程序的最佳时机，因为程序崩溃了之后你可以获取到调用栈信息，理想点的话还有错误发生位置的内核信息。为了达到这个情况，我们推荐在程序开始时校验所有参数的类型。

因为编码错误是无法被正确处理的，这个建议并不影响关于调用者可以使用try/catch或回调（事件发射器）处理错误而不能全用的结论。详见上一节"(不要)处理编码错误"。

下面是Node内置库函数推荐处理方式的例子，以大概的出现频率排序：

|  函数示例  | 类型 |	 错误示例  | 错误类型 |	如何传递 | 调用者如何处理 |
|-----------|----- |-----------|---------|----------|--------------|
|fs.stat    |	异步 | 找不到文件 | 运行错误 | 回调     | 处理回调错误   |
|JSON.parse |	同步 |用户输入错误| 运行错误 | 抛出     | try/catch     |
|fs.stat    |	异步 | 文件名为空 | 编码错误 | 抛出     | 啥都不做      |

异步函数中的运行错误（第一行）是目前为止最常见的情况。使用同步函数报告运行错误（第二行）在Node.js中非常少见，除了用户输入校验。但是在8.0之后Node.js开始支持async/await，导致大家开始使用promise处理异步操作，然后在try/catch块中用await语法来捕获promise的错误。编码错误（第三行）除了开发时之外是不应该发生的。

## 错误输入：编码错误还是运行错误？
如何分辨编码错误和运行错误呢？很简单：取决你如何定义和说明函数允许的输入类型以及你尝试如何描述它们。如果输入不是说明中允许的类型，那就是编码错误。如果输入是说明中允许的类型，但程序无法正确处理，那么就是运行错误。

你必须自己决定采用什么严格程度的设置，但我们还是能给你一些建议。详细地说，假设有一个叫做“connect”的函数，接受一个IP地址和一个回调作为参数，在执行成功或失败之后调用回调函数。假如某用户输入了一个明显不是有效IP地址的参数，比如'bob'。那么你有以下几种处理方式：

* 说明函数仅接受代表有效IP地址的字符串，如果用户输入了'bob'那就立即抛出异常(推荐)。
* 说明函数接受任何字符串。如果用户输入'bob'，那么发射一个异步错误表示无法连接到IP地址'bob'。

这些方案都符合运行错误和编码错误的指导原则。需要你自己认真决定是将该输入当做编码错误还是运行错误。一般来说，用户输入校验函数都非常宽松。比如说Date.parse，接收的输入种类非常宽泛。但对于大多数函数来说，我们强烈建议采取更严格的方案。函数越是尝试猜测调用者的意图（使用隐式类型转换，无论是JS自带还是函数中显式使用），则越可能猜错。比起因为要求详细而节省的时间，这么做可能会浪费开发者不少时间进行调试。此外，如果你觉得函数采用宽松处理方式不错的话，你可以一直保持下去，但是如果你发现猜测调用者意图这件事意味着奇怪的bug时，想要不影响兼容性的情况下修复问题可能就来不及了。

所以如果一个值不可能有效时（比如要求string时的undefined，要求ip地址时的其他字符串），你应该说明这是非法输入然后直接抛出错误。一旦你在文档中清楚说明，那么这些错误就是编码错误而不是运行错误。通过直接抛出错误，可以将bug导致的损失降到最小，同时保留了开发者调试所需要的信息（比如调用栈，如果使用了core dump的话，变量和内存也可以获取）。

## 那么域和process.on('uncaughtException')怎么样?
运行错误总是可以用显式地方法处理：捕获异常，回调中处理错误，处理事件发射器的"error"事件等等。域和进程范围的"uncaughtException"事件是主要用于处理意外的编码错误或者恢复服务。因为上文中谈到的原因，非常不推荐这么做。

### 撰写新函数的具体建议
我们提到了很多指导原则， 现在我们具体谈一谈。

>#### 1. 清楚你的函数要做什么
>这是唯一也是最重要的事情。每一个接口函数的文档都必须清楚说明：
>
>* 输入变量是什么
>* 这些变量的类型是什么
>* 任何变量的额外约束（比如，必须是有效的IP地址）
>
>如果其中任意一项缺失或者出错，那就是编码错误，请直接抛出异常。
>
>文档中同样可以说明：
>
>* 函数可能会抛出哪种运行时错误（包括名字）
>* 如何去处理运行时错误（比如错误会被抛出、传递给回调、通过事件发射器发射等）
>* 返回值

>#### 2. 对所有错误使用Error对象（或其子类），并且实现Error的约定
>你的所有错误应该使用Error类或其子类。你应该提供name和message属性，同样地调用栈应该有效（而且准确）。

>#### 3. 通过Error的name属性在程序中区分错误
>当你想要弄清楚错误是哪一类时，请用name属性。你可能想要复用的JS内置的错误名包括"RangeError"(变量值超出其有效范围)和"TypeError"（变量类型错误）。对HTTP错误来说，常见的方式是使用RFC定义好的状态为错误命名，比如"BadRequestError"或者"ServiceUnavailableError"。
>
>不需要给所有错误起新名字。你无需区分InvalidHostnameError, InvalidIpAddressError, InvalidDnsServerError等等，只需一个InvalidArgumentError，然后通过属性来查看到底是什么问题(见下文)。

>#### 4. 通过属性描述细节来扩展Error对象
>举例来说，如果一个变量无效，那么设置name属性为invalid、value属性为传递的值。如果是连接服务器失败，那么使用远程ip表明尝试连接的IP。如果是系统错误，那么使用syscall说明出错的指令，errno说明错误码。查看附录获取属性名示例。
>
>最起码，你需要：
>
>* name: 用于程序区分不同种类的错误（比如非法变量与连接失败）
>* message：人能看懂的错误信息。信息需要足够完整使得收到这个错误的人能够读取并理解。如果这个错误是从调用栈底层位置发出的，那么你应该在信息中增加解释你正在做什么。详见下一项如何包装错误。
>* stack: 一般来说，不要把它弄乱。甚至不要增加内容。V8只会在尝试读取错误属性时才计算它，这样是为了动态提高处理错误的性能。如果你读取错误属性仅仅是为了扩展它，那么会给调用者增加额外的开销，即便其并不需要调用栈。
>
>你应该在错误消息中包含足够的信息以便调用者可以据此构建自定义错误信息而无须解析你的错误。用户可能会将错误信息本地化、或者将错误信息聚合，或者差异化显示错误信息（比如，在web页面的表格里，或高亮表单输入错误）。

>#### 5. 如果你传递给调用者的错误是底层过来的，那么可以考虑包装一下
>你会发现你的异步函数funcA经常调用异步函数funcB，如果funcB发射了错误，那么你想让funcA也发射相同的错误。（注意funcA并不一定会想要发射错误。有时候会尝试重试。或者仅仅是无视错误因为没有合适的处理方法。但是我们这里仅仅考虑最简单的情况，就是funcA想要直接返回funcB的错误。）
>
>在本例中，考虑将错误包装起来而不是直接返回它。通过包装，我们想要抛出一个包含底层错误所有信息的新错误，此外添加上本级中额外的帮助信息。verror组件提供一种简单的实现方式。
>
>举例来说，假如你有一个函数fetchConfig，是从一个远程数据库获取服务器配置。也许你会在服务器启动时调用这个函数。启动时的整个路径看起来是这样：
>
> 1. 加载配置
>     1. 连接数据库服务器。包括：
>         1. 解析数据库服务器的DNS主机名
>         1. 同数据库建立TCP连接
>         1. 验证登陆信息
>     1. 发起DB请求
>     1. 解析回显
>     1. 加载配置
> 1. 开始处理请求
>假如在你尝试连接数据库服务器时发生了错误。如果1.1.2出错，因为无法路由至主机，然后每一级依次传递错误给调用者,但不包装，那么你收到的错误信息看起来可能就是：
>
>```
>myserver: Error: connect ECONNREFUSED
>```
>这明显并没有什么卵用
>
>另一方面，如果每一级将底层的错误进行包装的话，那么你收到的信息会更丰富：
>```
>myserver: failed to start up: failed to load configuration: failed to connect to database server: failed to connect to 127.0.0.1 port 1234: connect ECONNREFUSED
>```
>你可以省掉一些中间层包装让错误信息看起来更简练:
>```
>myserver: failed to load configuration: connection refused from database at 127.0.0.1 port 1234.
>```
>另一方面，最好多包含一些信息。
>
>如果你决定包装一个错误，那么是可以你需要考虑以下几点：
>
> * 保持原始错误完备,而且保证如果调用者想要直接查看某些信息时其仍然何用。
> * 包装错误使用相同的名称，或者选取一个更合理的。举个栗子，最底层可能是个普通的Node错误，但是从step 1中抛出的错误可能是InitializationError。（即使程序可以轻易通过错误属性来识别错误，也不要随便起一些新名字）
> * 保留原始错误的所有属性。按需增加message属性（但是不要更改原始错误）。对于syscall、errno等类似属性使用浅复制。你最好默认拷贝除了name,message和stack之外的所有属性，而不是硬编码一份需要拷贝的属性列表。不要对stack进行任何操作，甚至是读取都开销巨大。如果调用者想要合并调用栈，应该使用迭代出错信息并打印每一个的调用栈的方式去掉。
> * 在Joyent，我们使用verror组件去包装错误，因为它简明达意。如果采用这种方案，那你就不用亲自实现上述所有要求，只需继承即可。

### 一个例子
假设有一个异步连接IPv4地址TCP端口的函数。下方是一个如何撰写文档的例子：
```js
/*
 * Make a TCP connection to the given IPv4 address.  Arguments:
 *
 *    ip4addr        a string representing a valid IPv4 address
 *
 *    tcpPort        a positive integer representing a valid TCP port
 *
 *    timeout        a positive integer denoting the number of milliseconds
 *                   to wait for a response from the remote server before
 *                   considering the connection to have failed.
 *
 *    callback       invoked when the connection succeeds or fails.  Upon
 *                   success, callback is invoked as callback(null, socket),
 *                   where `socket` is a Node net.Socket object.  Upon failure,
 *                   callback is invoked as callback(err) instead.
 *
 * This function may fail for several reasons:
 *
 *    SystemError    For "connection refused" and "host unreachable" and other
 *                   errors returned by the connect(2) system call.  For these
 *                   errors, err.errno will be set to the actual errno symbolic
 *                   name.
 *
 *    TimeoutError   Emitted if "timeout" milliseconds elapse without
 *                   successfully completing the connection.
 *
 * All errors will have the conventional "remoteIp" and "remotePort" properties.
 * After any error, any socket that was created will be closed.
 */
function connect(ip4addr, tcpPort, timeout, callback) {
  assert.equal(typeof (ip4addr), 'string',
      "argument 'ip4addr' must be a string");
  assert.ok(net.isIPv4(ip4addr),
      "argument 'ip4addr' must be a valid IPv4 address");
  assert.equal(typeof (tcpPort), 'number',
      "argument 'tcpPort' must be a number");
  assert.ok(!isNaN(tcpPort) && tcpPort > 0 && tcpPort < 65536,
      "argument 'tcpPort' must be a positive integer between 1 and 65535");
  assert.equal(typeof (timeout), 'number',
      "argument 'timeout' must be a number");
  assert.ok(!isNaN(timeout) && timeout > 0,
      "argument 'timeout' must be a positive integer");
  assert.equal(typeof (callback), 'function');

  /* do work */
}
```
这个例子概念上很简单，但是包含了上述我们谈到的几个建议：

* 写明变量名、类型以及其他约束。
* 严格限制输入变量，如果输入错误就抛出错误（编码错误）。
* 写明可能发生的运行错误。不同的name属性用于逻辑上区分不同的错误，errno属性用于获取系统错误的详细信息。
* 写明错误传递的方式（错误发生时使用callback）。
* 返回的错误包含remoteIp和remotePort字段，便于用户自定义错误信息（比如，当用于http客户端时，其中会暗含端口信息）。
* 尽管显而易见，但连接失败后的状态也应该被清晰说明：任何打开的连接都会被关闭。

看起来是要比通常大家写一个易于理解的函数的工作要多，但是函数大多是不那么好理解的。建议应该避免臃肿，你应该自己判断什么东西是真正简单，但是请记住：十分钟的撰写文档时间可能会节省你或者其他人的数小时时间。

### 总结
* 学会区分运行错误和编码错误，一个是正确程序中可预期的、无法避免的错误（比如服务器连接失败），另一个则是程序中的bug。
* 运行错误能够也应该被处理。编码错误无法处理或可靠地恢复，尝试这么做的话会使得程序更难调试。
* 一个给定函数应该使用同步（throw）或者异步(回调、事件发射)方式来传递错误，但不能都用。用户应该能够使用try/catch或者在回调中处理错误，但是同样不能都用。一般来说，使用throw和try/catch的方式相当少，因为通常在Node.js程序中同步函数很少有运行错误（主要是用户输入校验函数比如JSON.parse）
* 写新函数时，文档中写明函数的期望输入、类型、其他限制（比如“必须是有效IP地址”），可以合法发生的运行错误（比如，解析域名失败、连接服务器失败、任何服务端错误），以及错误的传递方式（使用throw的同步方式，或者使用回调/事件发射的异步方式）
* 输入缺失或无效是编码错误，应该在发生时立即抛出。可能存在由作者决定哪些是可以接受的中间地带，但是如果你传给了一个函数其文档中没有注明接受的变量，那么这就是一个编码错误。
* 当传递错误时，使用标准Error类及其属性。然后在其他属性中添加需要的信息。尽可能使用常用变量名（参考下方）

## 附录：Error对象常用属性
强烈推荐使用这些名字以同Node内核及内核插件传递的错误保持一致。大多数名字并不会应用到任何给定错误中，但是如果含义不清的话，你应该在错误中加入任何看起来有用的信息，无论是编码上的还是通用的错误信息。

|  属性名  |  使用场景  |
|-------------|-------------|
|localHostname|	本地DNS主机名（比如那些你允许在其上建立连接的）|
|localIp|	本地IP地址（比如那些你允许在其上建立连接的）|
|localPort|	本地TCP端口（比如那些你允许在其上建立连接的）|
|remoteHostname|	其他服务的DNS主机名（比如那些你尝试连接的）|
|remoteIp|	其他服务的IP地址（比如那些你尝试连接的）|
|remotePort|	其他服务的端口（比如那些你尝试连接的）|
|path|	文件名、路径或者UNix域套接字（比如那些你尝试打开的）|
|srcpath|	作为源的路径名（比如用于重命名或复制）|
|dstpath|	作为目的的路径名（比如用于重命名或复制）|
|hostname|	DNS主机名（比如你尝试解析的）|
|ip|	ip地址（比如你尝试反解的）|
|propertyName	| 对象属性名，或者变量名（比如校验出错）|
|propertyValue|	属性值 (比如校验出错)|
|syscall|	失败的系统调用的名称|
|errno|	errno的字面值（比如“ENOENT”）。不要在实际上没有设置errno的C值的错误是使用它。而是用name来区分错误类型|
